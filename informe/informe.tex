\documentclass{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage[spanish]{babel}
\usepackage{multicol}
\usepackage{subcaption}
\usepackage{tikz}

\begin{document}
    \sloppypar
    \begin{titlepage}
        \centering
        {\bfseries\LARGE\texttt{Universidad de La Hábana} \par}
        \vspace{1cm}
        {\scshape\Large\texttt{Facultad de Matemáticas y Ciencias de la Computación} \par}
        \vfill
        {\scshape\Huge\texttt{Proyecto Final de DAA } \par}
        \vspace{1cm}
        {\scshape\LARGE\texttt{} \par}
        \vfill
        {\LARGE\texttt{Presentado por:} \par}
        \vspace{0.5cm}
        {\Large\texttt{Alex Sánchez Saez C412} \par}
        {\Large\texttt{Carlos Manuel González C411} \par}
        {\Large\texttt{Jorge Alberto Aspiolea González C412} \par}
        \vfill
        {\Large\texttt{Septiembre 2024} \par}
    \end{titlepage}
	\tableofcontents
	\newpage
	\section{Grid}
	\subsection{Problema}
	Un día iba Alex por su facultad cuando ve un cuadrado formado por $n \times n$  
cuadraditos de color blanco. A su lado, un mensaje ponía lo siguiente: "Las  
siguientes tuplas de la forma $(x_1, y_1, x_2, y_2)$ son coordenadas para pintar de  
negro algunos rectángulos. (coordenadas de la esquina inferior derecha y superior  
izquierda)" Luego se veían $k$ tuplas de cuatro enteros. Finalmente decía:  
"Luego de tener el cuadrado coloreado de negro en las secciones pertinentes, su  
tarea es invertir el cuadrado a su estado original. En una operación puede seleccionar  
un rectángulo y pintar todas sus casillas de blanco. El costo de pintar  
de blanco un rectángulo de $h \times w$ es el mínimo entre $h$ y $w$. Encuentre el costo  
mínimo para pintar de blanco todo el cuadrado."

En unos 10 minutos Alex fue capaz de resolver el problema. Desgraciadamente  
esto no es una película y el problema de Alex no era un problema  
del milenio que lo volviera millonario. Pero, ¿sería usted capaz de resolverlo  
también?
	
	\subsubsection{Entrada}
	La primera línea consiste en dos números $n$ y $m$, el tamaño del cuadrado y la cantidad de rectángulos respectivamente. A continuación seguirán $m$ lineas, cada una con 4 números $x1$, $y1$, $x2$, $y2$, $0 \leq x1,x2,y1,y2 \leq n-1$ indicando las coordenada superior izquierda e inferior derecha del rectaguno en el cuadrado respectivamente.
	\subsubsection{Salida}
	Un número entero indicando el costo mínimo de revertir el color de todos los rectángulos a blanco.
	\subsection{Técnicas de solución empleadas}
	\begin{itemize}
	\item Backtrack
	\item Greedy
	\end{itemize}
	
	\subsection{Backtrack}
	Del problema tenemos un cuadrado en donde fueron pintados algunos rectángulos los cuales pueden solaparse entre ellos tanto parcial como completamente. Nuestra primera solución para atacar el problema fue crear la solución de fuerza bruta creando un backtrack para poder probar nuestras posteriores soluciones.
	\subsubsection{Optimizaciones}
	Podemos observar que si un rectangulo es cubierto por otros rectágunos, este no es necesario pintarlo ya que pintando a los que lo cubren se pintaría este también, evitándonos así un costo innecesario.

Aquí tendríamos otro problema y es en que orden se pintan los cuadrados para asegurarnos de que siempre se pintan solo los necesarios?

Para esto definamos algúnos puntos importantes. 
\begin{itemize}

\item Si un rectángulo $A$ esta completamente contenido dentro de otro $B$, no es necesario pintar $A$ y sólo pintaríamos $B$. Esto es así porque aunque pintemos $A$, igual necesitaríamos pintar $B$, sin embargo si pintamos solo $B$ este cubriría $A$, por lo que solo tendríamos el costo de pintar uno solo.
\item Si un rectángulo $A$ tiene al menos una casilla la cual no es cubierta por ningún otro rectangulo, entonces hay que pintar $A$ obligatioriamente. Esto es obvio ya que pintando los demas rectángulos solo pintaríamos una parte de $A$ quedando algunas casillas en negro todavía que solo serán pintadas de blanco si y solo si pintamos $A$ directamente.
\end{itemize}

Sabiendo esto entonces podemos ordenar los rectángulos por área con un costo de $O(\log n)$ y comprobando si hay alguno de los dos casos anteriores se cumplen.

\begin{itemize}

\item Si hay una casilla que solo es cubierta por el propio rectángulo entonces se pinta
\item Si el rectangulo está cubierto completamente por otros rectángulos más grandes entonces omitimos pintar este rectangulo y simplemente esperamos a pintar los rectángulos más grandes que los cubren.

\end{itemize}
Este método nos acerca más a la solución pero el costo computacional sigue siendo elevado, ya que estaríamos comprobando por cada rectangulo si algúnos otros lo cubren completa o parcialmente. Esto para un rectángulo tiene un costo computacional de $O(n^3)$, recorriendo cada rectángulo $O(n-1) = O(n)$ y por cada uno recorrer todas las casillas de ese rectángulo buscando coincidencias $O(n^2)$, dándonos un costo computacionar por cada rectángulo de $O(n^3)$. Esto, para cada rectángulo del cuadrado es $O(n^4)$

Esta solución tiene un caso que nos falla, el cual abordaremos más adelante.
	\subsubsection{Problemas con este enfoque}
	
	El enfoque planteado hasta ahora, aunque no define una solución completa, si especifica como podemos enfrentar los posibles casos al plantear la solución final. Pero este tiene un problema.

Pensemos que siguiendo este enfoque empezando del rectángulo más pequeño al más grande, si encontrarmos un rectángulo $i$ que es cubierto por un rectángulo mayor $i + k$, estaríamos delegando la tarea de pintar el rectágulo $i$ al rectángulo $i + k$, pero, cómo sabemos que el rectángulo $i + k$ es el más grande posible que cubre al rectángulo más pequeño? Como nosotros solo almacenamos la cantidad de rectángulos que cubren una casilla, entonces pasa lo siguiente:

Si el rectángulo tiene todas sus casillas mayores a uno entonces se lo delegamos a los rectángulos que vienen más a delante. Pero cuando llegemos a un rectangulo con las mismas casillas, o sea que cubre parcialmente el rectangulo anterior, como este posiblemente pueda tener todas sus casillas mayores a uno se estaría delegando la tarea de pintar a otro rectángulo, y así sucesivamente hasta el final, en donde si todos los rectángulo tenían numeros mayores que uno nunca se habría sumado esos costos.

Para enfrentar esto podemos hacer lo siguente: Al recorrer los rectángulos de menor a mayor, si este tiene al menos un uno, entonces lo pintamos, sino restamos uno a todas sus casillas del rectángulo. Esto garantiza que si cuando un rectángulo mas grande pase por una casilla que previamente era mayor que uno pero para ese momento ya su valor es uno, indica que él es el ultimo rectángulo que queda que debería pintar dicha casilla, ya que los mas pequeños que él "borraron" su color de esa casilla con la seguridad que un rectángulo más adelante lo pintará por él.
\subsection{Analisis de correctitud}
	Hasta ahora tenemos claro que:
	\begin{itemize}
	
\item Si un rectángulo $A_{w \times h}$ tiene al menos un cuadrado que solo es pintado de negro por él mismo entonces este rectángulo hay que pintarlo de completamente con un costo de $\min {(w, h)}$.

\item Si un rectángulo $A_{w_1 \times h_1}$ es \textbf{cubierto completamente} por al menos un rectángulo $B_{ w_2 \times h_2}$ tal que $w_1 \leq w_2$ y $h1 \leq h_2$, o sea, por un rectángulo mayor o igual a él que lo cubra completamente, entonces no es necesario pintar $A$ ya que pintando $B$ se cubre $A$, y el costo sería $\min{(w_2, h_2)}$.
\item Si un rectángulo $A_{w \times h}$ está cubierto completamente pero por más de un rectángulo, entonces si pintamos $A$ sólo pintaríamos parcialmente los demás rectángulos, por lo que el costo total sería el costo de pintar $A$ más el costo de pintar los demás, pero si delegamos la tarea de pintar $A$ a los restantes rectángulos, el costo total solo sería el de pintar los demás.
\item Se garantiza que pintando los rectángulos de menor a mayor con criterio de ordenación por área éste dará una respuesta correcta porque:
  
\item Los más pequeños solo hay que pintarlos si no están cubiertos completamente por uno mas grande.
\item Si un rectangulo grande está cubierto por varios rectángulos más pequeños y a su vez, el rectángulo grande está cubriendo a los más pequeños (vease como que el grande es una composición de rectángulos mas pequeños), entonces el coste óptimo es pintar el grande. Sea $A_{w \times h}$ el rectángulo grande y asumamos que hay $n$ rectángulos más pequeños $B^{i}_{w_i \times h_i}$, tal que $\forall B^{i}_{w_i \times h_i}, w_i = w \lor h_i = h$, o sea, que todos los rectángulos $B$ cubran a $A$ a todo los alto o a todo lo ancho. 
  
  \end{itemize}

    Con este emplo garantizamos que solo hallan rectángulos en horizontal o en vertial, pero que no hallan intermedios (figura de abajo). Si se cumple esto entonces el pintar los rectangulos mas pequeños entonces la suma de sus lados más pequeños $h_i$ o $w_i$, entonces $\sum{h_i} = h \land \sum{w_i} = w$. En este caso, si $\forall w_i \leq h_i$, pero $h \leq w$ entonces la solución óptima sería $w$ (porque es la suma de los lados más pequeños), sin embargo esto es un error ya que la solución optimas es $h$, por lo que es mejor pintar $A$ directamente.
    Si por el contrario, $\forall w_i \leq h_i$, y $w \leq h$ entonces la solución óptima si es $w$, entonces da igual pintar $A$ antes que los $B^{i}$ que viceversa, la solución es la misma.
  
   Si el caso anterior no se cumple y $A$ está formado por varios rectángulos $B^{i}$ pero no todos sus lados son iguales a $w$ o a $h$ como en el caso anterior, quiere decir que hay rectángulos intermedios, (TODO: poner la foto debajo), por lo que la $\sum{w_i} \geq w \lor \sum{h_i} \geq h$, y la solución optima en estos dos casos simpre va a ser pintar $A$ primero.

 Con lo anterior y siguendo la estrategia de descontar uno cada vez que encontramos un rectángulo que es cubierto por uno o varios mas grandes aseguramos como bien dijimos anteriormente, que en cada paso que restamos uno a cada casilla es como si estubiéramos "eliminando" ese rectángulo sin ningún costo, ya que uno o varios mas grandes que él lo cubrirán.
\section{El Laberinto}
	\subsection{Problema}
	En tiempos antiguos, esos cuando los edificios se derrumbaban por mal tiempo y la conexión mágica era muy lenta, los héroes del reino se aventuraban en el legendario laberinto, un intrincado entramado de pasillos, cada uno custodiado por una bestia mágica. Los pasillos sólo podían caminarse en un sentido pues un viento muy fuerte no te dejaba regresar. Se decía que las criaturas del laberinto, uniendo sus fuerzas mágicas (garras y eso), habían creado ciclos dentro de este, atrapando a cualquiera que entrara a ellos en una especie de montaña rusa sin final en la que un monstruo se reía de ti cada vez que le pasabas por al lado, una locura.

El joven héroe Carlos, se enfrentaba a una prueba única: desmantelar los ciclos eternos y liberar los pasillos del laberinto para que su gente pudiera cruzarlo sin caer en los bucles infinitos de burla y depravación.

Cada vez que el héroe asesinaba cruelmente (no importa porque somos los buenos) a la criatura que cuidaba una un camino, este se rompía y desaparecía. Orión era fuerte, pero no tanto, debía optimizar bien a cuántos monstruos enfrentarse. Ayude al héroe encontrando la mínima cantidad de monstruos que debe matar para eliminar todas las montañas rusas de burla y depravación.
	\subsection{Primer contacto}
	El problema puede ser resumido a encontrar la menor cantidad de pasillos del
laberinto que debemos eliminar para eliminar los ciclos del laberinto , modelando el laberinto como un conjunto de salas conectadas por pasillos unidireccionales, podr´ıamos tomar las salas como nodos y los pasillos como arcos de un Digrafo c´ıclico (si no hay ciclios no tiene sentido el ejercicio)
	\subsubsection{Comprobación en tiempo polinomial}
	Si queremos comprobar una solución <G,k> es decir si eliminando k arcos eliminamos los ciclos. Simplemente eliminamos esos k arcos y comprobamos que no queden ciclos en el grafo resultante. Usando algoritmos como Floyd Warshall O($V^3$), verificando aristas de retroceso con Dfs O(V(G)+E(G)) etc). Por lo que verificar una solución es posible en tiempo polinomial.
	\subsection{Reduciendo a Vertex Cover}
Supongamos que tenemos un grafo G,convirtámoslo en un grafo dirigido.
Siguiendo las siguientes reglas:

\begin{enumerate}
  \item Por cada vertice $u \in V(G)$ creamos en Gf(grafo dirigido resultante) dos vértices u\_in y u\_out y conectamos u\_in con u\_out
  \item Por cada arista ${u,v} \in E(G)$ conectamos u\_out con v\_in y v\_out con u\_in en Gf
\end{enumerate}

\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
        % Primer grafo
        \node[draw, circle] (A) at (0, 0) {A};
        \node[draw, circle] (B) at (2, 0) {B};
        \node[draw, circle] (C) at (1, 2) {C};
        \draw (A) -- (B);
        \draw (B) -- (C);
        \draw (C) -- (A);
    \end{tikzpicture}
    \captionof{figure}{Grafo $G$}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}
        % Segundo grafo (dirigido, con nodos n_in y n_out)
        \node[draw, circle] (Ain) at (0, 1) {A\_in};
        \node[draw, circle] (Aout) at (0, -1) {A\_out};
        
        \node[draw, circle] (Bin) at (2, 1) {B\_in};
        \node[draw, circle] (Bout) at (2, -1) {B\_out};
        
        \node[draw, circle] (Cin) at (2, 3) {C\_in};
        \node[draw, circle] (Cout) at (0, 3) {C\_out};
        
        % Aristas dirigidas
        \draw[->] (Aout) -- (Bin);
        \draw[->] (Bout) -- (Cin);
        \draw[->] (Cout) -- (Ain);
        
        % Conexiones internas de nodos
        \draw[->] (Ain) -- (Aout);
         \draw[->] (Aout) -- (Bin);
           \draw[->] (Bout) -- (Ain);
        \draw[->] (Bin) -- (Bout);
           \draw[->] (Cin) -- (Bout);
     \draw[->] (Bin) -- (Cout);
        \draw[->] (Cin) -- (Cout);
           \draw[->] (Cin) -- (Aout);
              \draw[->] (Ain) -- (Cout);
    \end{tikzpicture}
    \captionof{figure}{Grafo resultante $G_f$}
\end{minipage}
Esta transformación es posible hacerla en tiempo polinomial siguiendo las dos reglas anteriores por cada nodo , por lo que la transformación se haría en O(V(G))

Por cada vértice en G se construye un ciclo en Gf, asumimos que el grafo no tiene vertices aislados de tener estos sería imposible hacer vertex cover y no tendría sentido la reducción. Por tanto si existiera un algoritmo que resolviera este problema en una complejidad polinomial, se pudiera transformar a vertex Cover en una complejidad polinomial, por tanto se resolvería Vertex Cover en una complejidad polinomial , no puede pasar pq Vertex Cover está demostrado es NP-Hard. Por tanto el problema en cuestión es NP-Completo

	\section{El Profe}

	\subsection{Problema}
	Jorge es profesor de programación. En sus ratos libres, le gusta divertirse con las estadísticas de sus pobres estudiantes reprobados. Los estudiantes están separados en $n$ grupos. Casualmente, este año, todos los estudiantes reprobaron alguno de los dos exámenes finales: $P$ (POO) y $R$ (Recursividad).

Esta tarde, Jorge decide entretenerse separando a los estudiantes suspensos en conjuntos de tamaño $k$ que cumplan lo siguiente: En un mismo conjunto, todos los estudiantes son del mismo grupo $i$ ($1 \leq i \leq n$) o suspendieron por el mismo examen $P$ o $R$.

Conociendo el grupo y la prueba suspendida de cada estudiante, y el tamaño de los conjuntos, ayude a Jorge a saber cuántos conjuntos de estudiantes suspensos puede formar.
\end{document}
    